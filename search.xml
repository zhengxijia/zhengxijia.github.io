<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于值传递和引用传递</title>
      <link href="/2018/04/05/%E5%85%B3%E4%BA%8E%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
      <url>/2018/04/05/%E5%85%B3%E4%BA%8E%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<p>今天去面试,被问到了一道题目,大致意思如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.change(a);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    b=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>问:经过方法change()后,程序最终会输出什么?</li><li>答:输出结果为1,原因是<code>变量a</code>并不是静态变量<code>static</code>,所以经过方法后数值会变,此刻面试官神情有点凝重,自行脑补~</li></ul><p>回来之后,经过一番资料查找和思考,才发现这是一个涉及<strong>值传递和引用传递</strong>的题目</p><p>首先,在java中,并没有指针这一说法,指针是C语言中的概念,但是其实在Java中的底层设计中,其实很多地方都用到了<strong>“封装好的指针”</strong>,也就是java中所说的引用地址.(引用和指针是两个完全不同的概念,但是此种情况下,可以等效对比进行学习)</p><p><strong>值传递</strong>(此处还是引用上面的题目)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">x <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">this</span>.change(a);    </span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    b=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:0</p><p>原因:int类型是基本数据类型,数据会开辟不同的栈区</p><p><img src="/2018/04/05/关于值传递和引用传递/test.png" alt="值传递"></p><p><strong>引用传递</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testRef</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StringBuffer x=<span class="keyword">new</span> StringBuffer(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">this</span>.change(x);</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(StringBuffer i)</span></span>&#123;</span><br><span class="line">i.append(<span class="string">" world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:Hello world!</p><p>原因:StringBuffer长度可变,append()方法会改变堆内存中的数据,程序运行流程如下图</p><p><img src="/2018/04/05/关于值传递和引用传递/testRef.png" alt="引用传递"></p><p>一个经典的值传递面试题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y=<span class="number">1</span>;</span><br><span class="line">    switchValue(x,y);</span><br><span class="line">    System.out.println(<span class="string">"x="</span>+x);</span><br><span class="line">    System.out.println(<span class="string">"y="</span>+y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">switchValue</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:x=0      y=1;</p><p>一个经典的引用传递面试题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> testSB&#123;</span><br><span class="line">    StringBuffer a=<span class="keyword">new</span> StringBuffer(<span class="string">"Hello"</span>);</span><br><span class="line">    StringBuffer b=a;</span><br><span class="line">    a.append(<span class="string">" World!"</span>);</span><br><span class="line">    a=b;</span><br><span class="line">    System.out.println(<span class="string">"a="</span>+a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:a=Hello World!</p><p><strong>总结</strong>:</p><ol><li><p>基本类型的变量保存原始值，所以变量就是数据本身。</p><p>常见的基本类型：byte,short,int,long,char,float,double,Boolean。</p></li><li><p>引用类型的变量保存引用值，所谓的引用值就是对象所在内存空间的“首地址值”，通过对这个引用值来操作对象。</p><p>常见的引用类型：类类型，接口类型和数组。</p><p><strong>注意:String类型比较特殊,底层是final修饰的char类型</strong>,要具体看源代码进行分析</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo如何插入本地图片</title>
      <link href="/2018/04/03/Hexo%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"/>
      <url>/2018/04/03/Hexo%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>最近刚开始玩Hexo,感觉很不错,特别是用MarkDown写文章,简直是一件很简洁舒服的事情,但是最近发现图片的插入是个问题,网上很多人都是用第三方服务来存储图片,最后再通过链接地址来显示图片,一来二去感觉很麻烦,经过一番搜索发现,可以用以下方法解决:</p><ol><li><p>首先在_config.yml中将属性设置为post_asset_folder:true,一开始默认为false</p></li><li><p>在hexo目录下安装一个可以上传本地图片的插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure></li><li><p>运行<code>hexo n &quot;xxx&quot;</code>来生成MarkDown文件时,发现 <code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹(注意:右键创建<code>xxxx.md</code>或者<code>touch xxxx.md</code>不会生成对应的文件夹) </p></li><li><p>将图片放在对应的文件夹中,例如图片<code>logo.jpg</code>,只要在MarkDown文件中引入<code>![Im a Boy](文件夹名/boy.jpg)</code> 就可以插入图片。</p></li></ol><p>其中<code>[]</code>为图片标题,<code>()</code>中为图片相对路径,生成的html为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;/2019/04/03/本地图片测试/boy.jpg&quot; alt=&quot;boy&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="/2018/04/03/Hexo如何插入本地图片/boy.jpg" alt="Im a Boy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring通过DI(依赖注入)实现IOC(控制反转)</title>
      <link href="/2018/02/21/Spring%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/02/21/Spring%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>常用的注解方式:<strong>构造器注入，setter注入，注解AutoWired的注入</strong> </p><h5 id="1-构造方法注入"><a href="#1-构造方法注入" class="headerlink" title="1.构造方法注入"></a>1.构造方法注入</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class RedisService &#123;</span><br><span class="line"></span><br><span class="line">    private final RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    public UserService(RedisTemplate redisTemplate) &#123;</span><br><span class="line">        this.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册RedisService --&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.vic.www.service.RedisService&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;redisTemplate&quot; ref=&quot;redisTemplate&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">//注意:ref=&quot;redisTemplate&quot;中的redisTemplate已经被Spring中的IOC管理,这里省略配置</span><br></pre></td></tr></table></figure><h5 id="2-setter方法注入"><a href="#2-setter方法注入" class="headerlink" title="2.setter方法注入"></a>2.setter方法注入</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class RedisService &#123;</span><br><span class="line"></span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line"> public void setRedisTemplate(RedisTemplate redisTemplate)&#123;</span><br><span class="line">        this.redisTemplate =  redisTemplate;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册RedisService --&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.vic.www.service.RedisService&quot;&gt;</span><br><span class="line">    &lt;property  name=&quot;redisTemplate&quot; ref=&quot;redisTemplate&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">//注意:ref=&quot;redisTemplate&quot;中的redisTemplate已经被Spring中的IOC管理,这里省略配置</span><br></pre></td></tr></table></figure><h5 id="3-注解AutoWired注入"><a href="#3-注解AutoWired注入" class="headerlink" title="3.注解AutoWired注入"></a>3.注解AutoWired注入</h5><p>autowire主要有三个属性值：constructor，byName，byType (默认)</p><p>主要有四种注解可以注册bean，每种注解可以任意使用，只是语义上有所差异：</p><ol><li><strong>@Component</strong>：可以用于注册所有bean</li><li><strong>@Repository</strong>：主要用于注册dao层的bean</li><li><strong>@Controller</strong>：主要用于注册控制层的bean</li><li><strong>@Service</strong>：主要用于注册服务层的bean</li></ol><p>描述依赖关系主要有两种： </p><ol><li><p><strong>@Resource</strong>：java的注解,默认以byName的方式去匹配与属性名相同的bean的id，如果没有找到就会以byType的方式查找，如果byType查找到多个的话，使用@Qualifier注解（spring注解）指定某个具体名称的bean。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">@Qualifier(&quot;redisTemplate&quot;)</span><br><span class="line">private RedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>@Autowired</strong>：spring注解,默认是以byType的方式去匹配与属性名相同的bean的id，如果没有找到，就通过byName的方式去查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;redisTemplate&quot;)</span><br><span class="line">private RedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong>：虽然有三种注入方式，但是最为开发中常见的是基于注解的方式,如果想要引用一些非自定义的类,可以在构造器注入和属性注入较为方便,如果一个接口有多个实现类,可以用@Qualifier标签进行指定</p>]]></content>
      
      
      <categories>
          
          <category> categories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
